<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SMART REST API</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet" media="screen">
    <link href="/assets/css/smart-docs.css" rel="stylesheet" media="screen">
    <link href="/assets/css/syntax.css" rel="stylesheet">
    <style type="text/css">
       body { padding-top: 0; }
      .sidebar-nav { padding: 9px 0; }
    </style>
    <link href="/assets/css/bootstrap-responsive.css" rel="stylesheet">
    <script src="http://code.jquery.com/jquery.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>
    <script>
        $(function(){ $('#sidebar').height($(window).height() - 100); })
    </script>
  </head>

  <body>
    <div class="navbar">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="/"><img style='height: 25px; width: 30px' src='/assets/img/smart-bug.png'></a>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li><a href="#about">Home</a></li>
              <li><a href="#about">App Dev</a></li>
              <li><a href="#about">Framework Guide</a></li>
              <li><a href="#about">Data Models</a></li>
              <li class="active"><a href="#about">API</a></li>
              <li><a href="#about">Container Dev</a></li>
              <li><a href="#about">FAQ</a></li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span3">
          <div id='sidebar' class="well sidebar-nav" style='overflow-y: scroll'>
            <ul class="nav nav-list">

              <!-- NAV START MARKER -->
              <!-- NAV END MARKER -->

              <li class="nav-header">Sidebar</li>
              <li class="active"><a href="#">Link</a></li>
              <li><a href="#">Link</a></li>
              <li><a href="#">Link</a></li>
              <li><a href="#">Link</a></li>
              <li class="nav-header">Sidebar</li>
              <li><a href="#">Link</a></li>
              <li><a href="#">Link</a></li>
            </ul>
          </div>
        </div><!--span3-->

        <div class="span9">
          <h2>SMART REST API</h2>

<div class="well">
  <p>N.B. This is highly preliminary, not a commitment or final
  version of any particular API or data model. This is purely
  for internal collaboration and preview purposes.</p>
</div>

<h3>Overview</h3>

<p>The SMART API provides access to individual resources (medications, fulfillment
events, prescription events, problems, etc.) and groups of these resources in a
<a href="http://en.wikipedia.org/wiki/Representational_state_transfer">RESTful</a> API.</p>

<h3>REST Design Principles</h3>

<p>In general you can interact with a:</p>

<ul>
<li>Group of resources using:

<ul>
<li><code>GET</code> to retrieve a group of resources such as <code>/medications/</code></li>
</ul></li>
<li>Single resource using:

<ul>
<li><code>GET</code> to retrieve a single resource such as /medications/{medication_id}</li>
</ul></li>
</ul>

<h3>OWL Ontology File</h3>

<p>The API calls listed below, as well as the RDF/XML payloads, are also
defined in a machine-readable OWL file. The OWL file has been used to
generate the documentation below, as well as our client-side REST
libraries and API Playground app.</p>

<h3>Call Scopes</h3>

<p>Each <code>GET</code> call in the SMART REST API is listed below and grouped by the
&quot;scope&quot; or &quot;access control category&quot; the SMART container applies to the
call. The SMART container implements this access control using the OAuth
tokens passed in with each API request as described in the <a href="/howto/build_a_rest_app/">build a REST
App howto</a>. TODO</p>

<p>Currently there are three &quot;scopes&quot; or access control categories:</p>

<ol>
<li><p><code>Container</code> calls can be made by anyone against the container.
Examples of this type of call are fetching the container&#39;s manifest
and fetching the container&#39;s ontology.  These calls need not
be OAuth-signed (though it is not incorrect to sign them).</p></li>
<li><p><code>Record</code> calls are scoped to a (app, user, record) tuple e.g. calls
to fetch a patient&#39;s medical record data. An example would be getting
the medications in a patient&#39;s record. The OAuth credentials for
the app (e.g. the <code>consumer_key</code> and <code>consumer_secret</code>) and
previously fetched OAuth credentials from the server including the
<code>smart_record_id</code> These calls must be signed as &quot;3-legged&quot; 
OAuth requests, meaning they are signed with a combination of
the app&#39;s consumer token + access token.</p></li>
<li><p><code>User</code> calls are scoped to a (app, user) tuple and are used for
setting a user&#39;s preferences <em>for that app only</em>. These calls are also
signed as &quot;3-legged&quot; OAuth calls, using an app&#39;s consumer token +
access token. (Future versions of the SMART API may allow an app to 
read another&#39;s preferences or add a &quot;global&quot; set of user preferences.) </p></li>
</ol>

<hr>

<ul>
<li>Query Filters</li>
<li>OAuth Guide</li>
</ul>


          <hr>

          <h2>Container Calls</h2>

<h3>App Manifest</h3>

<ul>
<li>URI: <code> GET/apps/{descriptor}/manifest </code></li>
<li>Client method name: <code> get_app_manifest </code></li>
</ul>

<p>Returns a JSON SMART UI app manifest for the app matching {descriptor}, or 404.  Note that {descriptor} can be an app ID like &quot;got-statins <br><br>
<ul>
<li>URI: <code> GET/apps/manifests/ </code></li>
<li>Client method name: <code> get_app_manifests </code></li>
</ul>
Returns a JSON list of all SMART UI app manifests installed on the container. <br><br>
<a href="../data_model/#App_Manifest">App Manifest RDF</a></p>

<h3>ContainerManifest</h3>

<ul>
<li>URI: <code> GET/manifest </code></li>
<li>Client method name: <code> get_container_manifest </code></li>
</ul>

<p>Get manifest for a container <br><br>
<a href="../data_model/#ContainerManifest">ContainerManifest RDF</a></p>

<h3>Demographics</h3>

<ul>
<li>URI: <code> GET/records/search </code></li>
<li>Client method name: <code> search_records </code></li>
</ul>

<p>Get an RDF graph of sp:Demographics elements for all patients that match the query.  Matching treats family_name and given_name as the <em>beginning</em> of a name.  For instance given_name=&#39;J&#39; matches /^J/i and thus matchs &#39;Josh&#39;. Date of birth is an ISO8601 string like &quot;2008-03-21&quot;; gender is &quot;male&quot; or &quot;female&quot;.  Gender, date_of_birth, zipcode, and medical_record_number must match exactly.
    <br><br>
<a href="../data_model/#Demographics">Demographics RDF</a></p>

<h3>Ontology</h3>

<ul>
<li>URI: <code> GET/ontology </code></li>
<li>Client method name: <code> get_ontology </code></li>
</ul>

<p>Get the ontology used by a SMART container <br><br>
<a href="../data_model/#Ontology">Ontology RDF</a></p>

<h3>User</h3>

<ul>
<li>URI: <code> GET/users/search </code></li>
<li>Client method name: <code> search_users </code></li>
</ul>

<p>Get users by name (or all users if blank) <br><br>
<ul>
<li>URI: <code> GET/users/{user_id} </code></li>
<li>Client method name: <code> get_user </code></li>
</ul>
Get a single user by ID <br><br>
<a href="../data_model/#User">User RDF</a></p>

<h2>Record Calls</h2>

<h3>Allergy</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/allergies/{allergy_id} </code></li>
<li>Client method name: <code> get_allergy </code></li>
</ul>

<p>Get one Allergy for a patient <br><br>
<ul>
<li>URI: <code> GET/records/{record_id}/allergies/ </code></li>
<li>Client method name: <code> get_allergies </code></li>
</ul>
Get all Allergies and Allergy Exclusions for a patient <br><br>
<a href="../data_model/#Allergy">Allergy RDF</a></p>

<h3>Clinical Note</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/clinical_notes/{clinical_note_id} </code></li>
<li>Client method name: <code> get_clinical_note </code></li>
</ul>

<p>Get one Clinical Note for a patient <br><br>
<ul>
<li>URI: <code> POST/records/{record_id}/clinical_notes/ </code></li>
<li>Client method name: <code> post_clinical_note </code></li>
</ul>
Post a Clinical Note for a patient. The body of the post should contain SMART RDF/XML serialization of the clinical note without the belongsTo predicate. The clinical note will be added to the collection of notes and the call will return a a copy of the posted data to indicate as successful posting. <br><br>
<ul>
<li>URI: <code> GET/records/{record_id}/clinical_notes/ </code></li>
<li>Client method name: <code> get_clinical_notes </code></li>
</ul>
Get all Clinical Notes for a patient <br><br>
<a href="../data_model/#Clinical_Note">Clinical Note RDF</a></p>

<h3>Demographics</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/demographics </code></li>
<li>Client method name: <code> get_demographics </code></li>
</ul>

<p>Get Demographics for a patient <br><br>
<a href="../data_model/#Demographics">Demographics RDF</a></p>

<h3>Document</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/documents/ </code></li>
<li>Client method name: <code> get_documents </code></li>
</ul>

<p>Returns data about all the available documents for the patient record subject to the standard filter restrictions. The optional <code>format</code> parameter sets the output format of the call. The possible values are <code>metadata</code> and <code>combined</code>. In <code>format=metadata</code> mode, the container returns metadata and desceriptors of the documents in RDF-XML. In <code>format=combined</code> mode the call returns the serialized documents&#39; content in addition to all the data from the <code>format=metadata</code> mode. In the absence of a <code>format</code> parameter, the API defaults to <code>format=metadata</code>. <br><br>
<ul>
<li>URI: <code> GET/records/{record_id}/documents/{document_id} </code></li>
<li>Client method name: <code> get_document </code></li>
</ul>
Allows a SMART app to request a single document. The optional <code>format</code> parameter sets the output format of the call. The possible values are <code>metadata</code>, <code>raw</code>, and <code>combined</code>. In <code>format=metadata</code> mode, the container returns metadata and desceriptors of the document in RDF-XML. In <code>format=combined</code> mode the call returns the serialized document content in addition to all the data from the <code>format=metadata</code> mode. In <code>format=raw</code> mode, SMART returns the raw document content with the proper MIME type. In the absence of a <code>format</code> parameter, the API defaults to <code>format=raw</code>. <br><br>
<a href="../data_model/#Document">Document RDF</a></p>

<h3>Encounter</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/encounters/{encounter_id} </code></li>
<li>Client method name: <code> get_encounter </code></li>
</ul>

<p>Get one Encounter for a patient <br><br>
<ul>
<li>URI: <code> GET/records/{record_id}/encounters/ </code></li>
<li>Client method name: <code> get_encounters </code></li>
</ul>
Get all Encounters for a patient <br><br>
<a href="../data_model/#Encounter">Encounter RDF</a></p>

<h3>Family History Observation</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/family_history/{family_history_id} </code></li>
<li>Client method name: <code> get_family_history_observation </code></li>
</ul>

<p>Get one Family History for a patient <br><br>
<ul>
<li>URI: <code> GET/records/{record_id}/family_history/ </code></li>
<li>Client method name: <code> get_family_history_observations </code></li>
</ul>
Get all Family Histories for a patient <br><br>
<a href="../data_model/#Family_History_Observation">Family History Observation RDF</a></p>

<h3>Fulfillment</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/fulfillments/ </code></li>
<li>Client method name: <code> get_fulfillments </code></li>
</ul>

<p>Get all Fulfillments for a patient <br><br>
<ul>
<li>URI: <code> GET/records/{record_id}/fulfillments/{fulfillment_id} </code></li>
<li>Client method name: <code> get_fulfillment </code></li>
</ul>
Get one Fulfillment for a patient <br><br>
<a href="../data_model/#Fulfillment">Fulfillment RDF</a></p>

<h3>Immunization</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/immunizations/ </code></li>
<li>Client method name: <code> get_immunizations </code></li>
</ul>

<p>Get all Immunizations for a patient <br><br>
<ul>
<li>URI: <code> GET/records/{record_id}/immunizations/{immunization_id} </code></li>
<li>Client method name: <code> get_immunization </code></li>
</ul>
Get one Immunization for a patient <br><br>
<a href="../data_model/#Immunization">Immunization RDF</a></p>

<h3>Lab Panel</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/lab_panels/ </code></li>
<li>Client method name: <code> get_lab_panel </code></li>
</ul>

<p>Get one Lab Panel for a patient <br><br>
<ul>
<li>URI: <code> GET/records/{record_id}/lab_panels/ </code></li>
<li>Client method name: <code> get_lab_panels </code></li>
</ul>
Get all Lab Panels for a patient <br><br>
<a href="../data_model/#Lab_Panel">Lab Panel RDF</a></p>

<h3>Lab Result</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/lab_results/ </code></li>
<li>Client method name: <code> get_lab_results </code></li>
</ul>

<p>Get all Lab Results for a patient <br><br>
<ul>
<li>URI: <code> GET/records/{record_id}/lab_results/{lab_result_id} </code></li>
<li>Client method name: <code> get_lab_result </code></li>
</ul>
Get one Lab Result for a patient <br><br>
<a href="../data_model/#Lab_Result">Lab Result RDF</a></p>

<h3>Medication</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/medications/ </code></li>
<li>Client method name: <code> get_medications </code></li>
</ul>

<p>Get all Medications for a patient <br><br>
<ul>
<li>URI: <code> GET/records/{record_id}/medications/{medication_id} </code></li>
<li>Client method name: <code> get_medication </code></li>
</ul>
Get one Medication for a patient <br><br>
<a href="../data_model/#Medication">Medication RDF</a></p>

<h3>Photograph</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/photograph </code></li>
<li>Client method name: <code> get_photograph </code></li>
</ul>

<p>Get one Photograph for a patient <br><br>
<a href="../data_model/#Photograph">Photograph RDF</a></p>

<h3>Problem</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/problems/ </code></li>
<li>Client method name: <code> get_problems </code></li>
</ul>

<p>Get all Problems for a patient <br><br>
<ul>
<li>URI: <code> GET/records/{record_id}/problems/{problem_id} </code></li>
<li>Client method name: <code> get_problem </code></li>
</ul>
Get one Problem for a patient <br><br>
<a href="../data_model/#Problem">Problem RDF</a></p>

<h3>Procedure</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/procedures/ </code></li>
<li>Client method name: <code> get_procedures </code></li>
</ul>

<p>Get all Procedures for a patient <br><br>
<ul>
<li>URI: <code> GET/records/{record_id}/procedures/{procedure_id} </code></li>
<li>Client method name: <code> get_procedure </code></li>
</ul>
Get one Procedure for a patient <br><br>
<a href="../data_model/#Procedure">Procedure RDF</a></p>

<h3>Scratchpad Data</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/apps/{smart_app_id}/scratchpad </code></li>
<li>Client method name: <code> get_scratchpad_data </code></li>
</ul>

<p>Returns the scratchpad blob unicode data stored in the patient&#39;s account by a previous run of the owner app in the response body. An app can ready any other app&#39;s scratchpad. If not data is available the call will return an empty string. <br><br>
<ul>
<li>URI: <code> DELETE/records/{record_id}/apps/{smart_app_id}/scratchpad </code></li>
<li>Client method name: <code> delete_scratchpad_data </code></li>
</ul>
Purges the scratchpad data stored in the SMART container for the selected app. If everything goes well, this call will respond with HTTP 200 status code. <br><br>
<ul>
<li>URI: <code> PUT/records/{record_id}/apps/{smart_app_id}/scratchpad </code></li>
<li>Client method name: <code> put_scratchpad_data </code></li>
</ul>
Stores scratchpad data in the patient&#39;s account in the SMART container scoped to the current app. The HTTP request body represents the unicode-encoded data blob. The app chooses the best format for the data that makes sense for its use case (it is unstructured from SMART&#39;s perspective). If the data save was successful, the SMART server will respond with an HTTP 200 code and include the stored data in the response body. It is the app&#39;s responsibility to compare the response with the intended data content. If there are any discrepancies, then a concurrency problem occured while writing the data and the app should request a fresh copy of the scratchpad data stored on the server, merge it with its local copy and attempt writing it again. <br><br>
<a href="../data_model/#Scratchpad_Data">Scratchpad Data RDF</a></p>

<h3>Social History</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/social_history </code></li>
<li>Client method name: <code> get_social_history </code></li>
</ul>

<p>Get Social History for a patient <br><br>
<a href="../data_model/#Social_History">Social History RDF</a></p>

<h3>Vital Sign Set</h3>

<ul>
<li>URI: <code> GET/records/{record_id}/vital_sign_sets/{vital_sign_set_id} </code></li>
<li>Client method name: <code> get_vital_sign_set </code></li>
</ul>

<p>Get one Vital Sign Set for a patient <br><br>
<ul>
<li>URI: <code> GET/records/{record_id}/vital_sign_sets/ </code></li>
<li>Client method name: <code> get_vital_sign_sets </code></li>
</ul>
Get all Vital Sign Sets for a patient <br><br>
<a href="../data_model/#Vital_Sign_Set">Vital Sign Set RDF</a></p>

<h2>User Calls</h2>

<h3>User Preferences</h3>

<ul>
<li>URI: <code> DELETE/users/{user_id}/apps/{smart_app_id}/preferences </code></li>
<li>Client method name: <code> delete_user_preferences </code></li>
</ul>

<p>Purges the user preferences stored in the SMART container for the selected app. If everything goes well, this call will respond with HTTP 200 status code. <br><br>
<ul>
<li>URI: <code> GET/users/{user_id}/apps/{smart_app_id}/preferences </code></li>
<li>Client method name: <code> get_user_preferences </code></li>
</ul>
Returns the preferences blob unicode data stored in the user&#39;s account by a previous run of the app in the response body. If not data is available the call will return an empty string. <br><br>
<ul>
<li>URI: <code> PUT/users/{user_id}/apps/{smart_app_id}/preferences </code></li>
<li>Client method name: <code> put_user_preferences </code></li>
</ul>
Stores preferences data in the user&#39;s account in the SMART container scoped to the current app. The HTTP request body represents the unicode-encoded data blob. The app chooses the best format for the data that makes sense for its use case (it is unstructured from SMART&#39;s perspective). If the data save was successful, the SMART server will respond with an HTTP 200 code and include the stored data in the response body. It is the app&#39;s responsibility to compare the response with the intended data content. If there are any discrepancies, then a concurrency problem occured while writing the data and the app should request a fresh copy of the preferences data stored on the server, merge it with its local copy and attempt writing it again. <br><br>
<a href="../data_model/#User_Preferences">User Preferences RDF</a></p>


        </div><!--span9-->
      </div><!--row-->

      <hr>

      <footer>
        <p>&copy; <a href='http://smartplatforms.org'>SMARTPlatforms.org 2013</p>
      </footer>

    </div><!--/.fluid-container-->
  </body>
</html>

